# 섹션 6-2. 형변환 정리
## 자동 형변환
- 자바는 기본적으로 같은 타입에 대입
- 다른 타입에 값을 대입하면?
  - 작은 범위에서 큰 범위로 대입 당연 가능
  - `int` < `long` < `double`
- 대입하는 형(타입)을 맞추려고 자동 형변환(묵시적 형변환)

## 명시적 형변환
- 작은 걸 큰 그릇에 넣을 때는 문제x
- 큰 범위를 작은 범위에 넣는다면?
  - `incompatible types: possible lossy conversion from double to int`
  - 호환되지 않는 유형. 손실 변환 
- 개발자가 위험을 감수하고 값을 대입할 때
- `(int)`괄호를 사용해서 명시적으로 타입 입력
- 단 값이 변하는 것 X

```java
//doubleValue = 1.5;
intValue = (int)doubleValue;
intValue = (int)1.5;
intValue = 1; //(int)로 형변환 한다. intValue에 int형인 숫자 1을 대입한다.
```
형변환 한다고 `doubleValue` 자체의 타입이 변경되거나 그 안에 있는 값이 변경되는 것은 아니다.  
`doubleValue`에서 읽은 값을 형변환 하는 것.  
`doubleValue` 안에 들어있는 값 1.5는 그대로 유지된다.  
변수의 값은 `=`(대입연산자)를 사용하여 직접 대입할 때만 변경된다.

## 형변환 오버플로우


### 출력결과
```result
maxIntValue casting = 2147483647
maxIntOver casting = -2147483648
```
전혀 다른 숫자 출력.
시계가 한바퀴 돈 것처럼 다시 처음부터 시작  
`-2147483648` 는 `int`의 가장 작은 숫자

- 오버플로우가 발생?
  - 타입을 바로 상위 타입으로 바꿔서 문제 해결해.
  - 숫자 계산X, 활용X
    
## 계산과 형변환
1. 같은 타입끼리 계산? 
   - 같은 타입의 결과
2. 서로 다른 타입 계산? 
   - 큰 범위로 자동 형변환

## 마무리
좋은 프로그램은 적절한 제약이 있는 프로그램  
타입은 제약의 끝판왕 
타입만 보고 개발자가 딱 알 수 있게됨   
제약이 있기 때문에 
